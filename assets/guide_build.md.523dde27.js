import{o as n,c as s,a}from"./app.348a6f9e.js";const t='{"title":"构建生产版本","description":"","frontmatter":{"title":"构建生产版本"},"headers":[{"level":2,"title":"浏览器兼容性","slug":"browser-compatibility"},{"level":2,"title":"公共基础路径","slug":"public-base-path"},{"level":2,"title":"自定义构建","slug":"customizing-the-build"},{"level":2,"title":"文件变化时重新构建","slug":"rebuild-on-files-changs"},{"level":2,"title":"多页面应用模式","slug":"multi-page-app"},{"level":2,"title":"库模式","slug":"library-mode"}],"relativePath":"guide/build.md","lastUpdated":1627281162742}',e={},o=a('<h1 id="building-for-production"><a class="header-anchor" href="#building-for-production" aria-hidden="true">#</a> 构建生产版本</h1><p>当需要将应用部署到生产环境时，只需运行 <code>vite build</code> 命令。默认情况下，它使用 <code>&lt;root&gt;/index.html</code> 作为其构建入口点，并生成能够静态部署的应用程序包。请查阅 <a href="./static-deploy.html">部署静态站点</a> 获取常见服务的部署指引。</p><h2 id="browser-compatibility"><a class="header-anchor" href="#browser-compatibility" aria-hidden="true">#</a> 浏览器兼容性</h2><p>用于生产环境的构建包会假设目标浏览器支持现代 JavaScript 语法。默认情况下，vite 的目标浏览器是指能够 <a href="https://caniuse.com/es6-module" target="_blank" rel="noopener noreferrer">支持原生 ESM script 标签</a> 和 <a href="https://caniuse.com/es6-module-dynamic-import" target="_blank" rel="noopener noreferrer">支持原生 ESM 动态导入</a> 的。作为参考，vite 使用这个 <a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener noreferrer">browserslist</a> 作为查询标准：</p><div class="language-"><pre><code>defaults and supports es6-module and supports es6-module-dynamic-import, not opera &gt; 0, not samsung &gt; 0, not and_qq &gt; 0\n</code></pre></div><p>你也可以通过 <a href="/config/#build-target"><code>build.target</code> 配置项</a> 指定构建目标，最低支持 <code>es2015</code>。</p><p>请注意，默认情况下 Vite 只处理语法转译，且 <strong>默认不包含任何 polyfill</strong>。你可以前往 <a href="https://polyfill.io/v3/" target="_blank" rel="noopener noreferrer">Polyfill.io</a> 查看，这是一个基于用户浏览器 User-Agent 字符串自动生成 polyfill 包的服务。</p><p>传统浏览器可以通过插件 <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy" target="_blank" rel="noopener noreferrer">@vitejs/plugin-legacy</a> 来支持，它将自动生成传统版本的 chunk 及与其相对应 ES 语言特性方面的 polyfill。兼容版的 chunk 只会在不支持原生 ESM 的浏览器中进行按需加载。</p><h2 id="public-base-path"><a class="header-anchor" href="#public-base-path" aria-hidden="true">#</a> 公共基础路径</h2><ul><li>相关内容：<a href="./assets.html">静态资源处理</a></li></ul><p>如果你需要在嵌套的公共路径下部署项目，只需指定 <a href="/config/#base"><code>base</code> 配置项</a>，然后所有资源的路径都将据此配置重写。这个选项也可以通过命令行参数指定，例如 <code>vite build --base=/my/public/path/</code>。</p><p>由 JS 引入的资源 URL，CSS 中的 <code>url()</code> 引用以及 <code>.html</code> 文件中引用的资源在构建过程中都会自动调整，以适配此选项。</p><p>当然，情况也有例外，当访问过程中需要使用动态连接的 url 时，可以使用全局注入的 <code>import.<wbr>meta.env.BASE_URL</code> 变量，它的值为公共基础路径。注意，这个变量在构建时会被静态替换，因此，它必须按 <code>import.<wbr>meta.env.BASE_URL</code> 的原样出现（例如 <code>import.<wbr>meta.env[&#39;BASE_URL&#39;]</code> 是无效的）</p><h2 id="customizing-the-build"><a class="header-anchor" href="#customizing-the-build" aria-hidden="true">#</a> 自定义构建</h2><p>构建过程可以通过多种 <a href="/config/#build-options">构建配置选项</a> 来自定义构建。具体来说，你可以通过 <code>build.rollupOptions</code> 直接调整底层的 <a href="https://rollupjs.org/guide/en/#big-list-of-options" target="_blank" rel="noopener noreferrer">Rollup 选项</a>：</p><div class="language-js"><pre><code><span class="token comment">// vite.config.js</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  build<span class="token operator">:</span> <span class="token punctuation">{</span>\n    rollupOptions<span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// https://rollupjs.org/guide/en/#big-list-of-options</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>例如，你可以使用仅在构建期间应用的插件来指定多个 Rollup 输出。</p><h2 id="rebuild-on-files-changs"><a class="header-anchor" href="#rebuild-on-files-changs" aria-hidden="true">#</a> 文件变化时重新构建</h2><p>你可以使用 <code>vite build --watch</code> 来启用 rollup 的监听器。或者，你可以直接通过 <code>build.watch</code> 调整底层的 <a href="https://rollupjs.org/guide/en/#watch-options" target="_blank" rel="noopener noreferrer"><code>WatcherOptions</code></a> 选项：</p><div class="language-js"><pre><code><span class="token comment">// vite.config.js</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  build<span class="token operator">:</span> <span class="token punctuation">{</span>\n    watch<span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// https://rollupjs.org/guide/en/#watch-options</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="multi-page-app"><a class="header-anchor" href="#multi-page-app" aria-hidden="true">#</a> 多页面应用模式</h2><p>假设你有下面这样的项目文件结构</p><div class="language-"><pre><code>├── package.json\n├── vite.config.js\n├── index.html\n├── main.js\n└── nested\n    ├── index.html\n    └── nested.js\n</code></pre></div><p>在开发过程中，简单地导航或链接到 <code>/nested/</code> - 将会按预期工作，与正常的静态文件服务器表现一致。</p><p>在构建过程中，你只需指定多个 <code>.html</code> 文件作为入口点即可：</p><div class="language-js"><pre><code><span class="token comment">// vite.config.js</span>\n<span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;path&#39;</span><span class="token punctuation">)</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  build<span class="token operator">:</span> <span class="token punctuation">{</span>\n    rollupOptions<span class="token operator">:</span> <span class="token punctuation">{</span>\n      input<span class="token operator">:</span> <span class="token punctuation">{</span>\n        main<span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;index.html&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n        nested<span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;nested/index.html&#39;</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>如果你指定了另一个根目录，请记住，在解析输入路径时，<code>__dirname</code> 的值将仍然是 vite.config.js 文件所在的目录。因此，你需要把对应入口文件的 <code>root</code> 的路径添加到 <code>resolve</code> 的参数中。</p><h2 id="library-mode"><a class="header-anchor" href="#library-mode" aria-hidden="true">#</a> 库模式</h2><p>当你开发面向浏览器的库时，你可能会将大部分时间花在该库的测试/演示页面上。在 Vite 中你可以使用 <code>index.html</code> 获得如丝般顺滑的开发体验。</p><p>当这个库要进行发布构建时，请使用 <a href="/config/#build-lib"><code>build.lib</code> 配置项</a>，以确保将那些你不想打包进库的依赖进行外部化处理，例如 <code>vue</code> 或 <code>react</code>：</p><div class="language-js"><pre><code><span class="token comment">// vite.config.js</span>\n<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;path&#39;</span><span class="token punctuation">)</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  build<span class="token operator">:</span> <span class="token punctuation">{</span>\n    lib<span class="token operator">:</span> <span class="token punctuation">{</span>\n      entry<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;lib/main.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      name<span class="token operator">:</span> <span class="token string">&#39;MyLib&#39;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    rollupOptions<span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 确保外部化处理那些你不想打包进库的依赖</span>\n      external<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;vue&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n      output<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量</span>\n        globals<span class="token operator">:</span> <span class="token punctuation">{</span>\n          vue<span class="token operator">:</span> <span class="token string">&#39;Vue&#39;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>使用如上配置运行 <code>vite build</code> 时，将会使用一套面向库的 Rollup 预设，并且将为该库提供两种构建格式：<code>es</code> 和 <code>umd</code> (可在 <code>build.lib</code> 中配置)：</p><div class="language-"><pre><code>$ vite build\nbuilding for production...\n[write] my-lib.es.js 0.08kb, brotli: 0.07kb\n[write] my-lib.umd.js 0.30kb, brotli: 0.16kb\n</code></pre></div><p>推荐在你库的 <code>package.json</code> 中使用如下格式：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;my-lib&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;files&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;dist&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./dist/my-lib.umd.js&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;module&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./dist/my-lib.es.js&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;.&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">&quot;import&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./dist/my-lib.es.js&quot;</span><span class="token punctuation">,</span>\n      <span class="token property">&quot;require&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./dist/my-lib.umd.js&quot;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div>',35);e.render=function(a,t,e,p,c,l){return n(),s("div",null,[o])};export default e;export{t as __pageData};
