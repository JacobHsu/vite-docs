import{o as e,c as o,a as n}from"./app.a2203fca.js";const a='{"title":"环境变量和模式","description":"","frontmatter":{"title":"环境变量和模式"},"headers":[{"level":2,"title":"环境变量","slug":"env-variables"},{"level":3,"title":"生产环境替换","slug":"production-replacement"},{"level":2,"title":".env 文件","slug":"env-files"},{"level":3,"title":"智能提示","slug":"intellisense"},{"level":2,"title":"模式","slug":"modes"}],"relativePath":"guide/env-and-mode.md","lastUpdated":1627354936992}',d={},t=n('<h1 id="env-variables-and-modes"><a class="header-anchor" href="#env-variables-and-modes" aria-hidden="true">#</a> 环境变量和模式</h1><h2 id="env-variables"><a class="header-anchor" href="#env-variables" aria-hidden="true">#</a> 环境变量</h2><p>Vite 在一个特殊的 <strong><code>import.<wbr>meta.env</code></strong> 对象上暴露环境变量。这里有一些在所有情况下都可以使用的内建变量：</p><ul><li><p><strong><code>import.<wbr>meta.env.MODE</code></strong>: {string} 应用运行的<a href="#modes">模式</a>。</p></li><li><p><strong><code>import.<wbr>meta.env.BASE_URL</code></strong>: {string} 部署应用时的基本 URL。他由<a href="/config/#base"><code>base</code> 配置项</a>决定。</p></li><li><p><strong><code>import.<wbr>meta.env.PROD</code></strong>: {boolean} 应用是否运行在生产环境。</p></li><li><p><strong><code>import.<wbr>meta.env.DEV</code></strong>: {boolean} 应用是否运行在开发环境 (永远与 <code>import.<wbr>meta.env.PROD</code>相反)。</p></li></ul><h3 id="production-replacement"><a class="header-anchor" href="#production-replacement" aria-hidden="true">#</a> 生产环境替换</h3><p>在生产环境中，这些环境变量会在构建时被<strong>静态替换</strong>，因此，在引用它们时请使用完全静态的字符串。动态的 key 将无法生效。例如，动态 key 取值 <code>import.<wbr>meta.env[key]</code> 是无效的。</p><p>它还将替换出现在 JavaScript 和 Vue 模板中的字符串。这应该是一种罕见的情况，但可能是不小心为之的。有一些方法可以避免这个问题：</p><ul><li><p>对于 JavaScript 字符串，你可以使用 unicode 零宽度空格 <strong><code>\\u200b</code></strong> (一个看不见的分隔符)来分割这个字符串，例如： <code>&#39;import.<wbr>meta\\u200b.env.MODE&#39;</code>。</p></li><li><p>对于 Vue 模板或其他编译到 JavaScript 字符串的 HTML，你可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr" target="_blank" rel="noopener noreferrer"><code>&lt;wbr&gt;</code> 标签</a>，例如：<code>import.<wbr>meta.&lt;wbr&gt;env.MODE</code>。</p></li></ul><h2 id="env-files"><a class="header-anchor" href="#env-files" aria-hidden="true">#</a> <code>.env</code>文件</h2><p>Vite 使用 <a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener noreferrer">dotenv</a> 从你的 <a href="/config/#envdir">环境目录</a> 中的下列文件加载额外的环境变量：</p><div class="language-"><pre><code>.env                # 所有情况下都会加载\n.env.local          # 所有情况下都会加载，但会被 git 忽略\n.env.[mode]         # 只在指定模式下加载\n.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略\n</code></pre></div><p>加载的环境变量也会通过 <code>import.<wbr>meta.env</code> 暴露给客户端源码。</p><p>为了防止意外地将一些环境变量泄漏到客户端，只有以 <code>VITE_</code> 为前缀的变量才会暴露给经过 vite 处理的代码。例如下面这个文件中：</p><div class="language-"><pre><code>DB_PASSWORD=foobar\nVITE_SOME_KEY=123\n</code></pre></div><p>只有 <code>VITE_SOME_KEY</code> 会被暴露为 <code>import.<wbr>meta.env.VITE_SOME_KEY</code> 提供给客户端源码，而 <code>DB_PASSWORD</code> 则不会。</p><div class="warning custom-block"><p class="custom-block-title">安全注意事项</p><ul><li><p><code>.env.*.local</code> 文件应是本地的，可以包含敏感变量。你应该将 <code>.local</code> 添加到你的 <code>.gitignore</code> 中，以避免它们被 git 检入。</p></li><li><p>由于任何暴露给 Vite 源码的变量最终都将出现在客户端包中，<code>VITE_*</code> 变量应该不包含任何敏感信息。</p></li></ul></div><h3 id="intellisense"><a class="header-anchor" href="#intellisense" aria-hidden="true">#</a> 智能提示</h3><p>默认情况下，Vite 为 <code>import.<wbr>meta.env</code> 提供了类型定义。随着在 <code>.env[mode]</code> 文件中自定义了越来越多的环境变量，你可能想要在代码中获取这些以 <code>VITE_</code> 为前缀的用户自定义环境变量的 TypeScript 智能提示。</p><p>要想做到这一点，你可以在 <code>src</code> 目录下创建一个 <code>env.d.ts</code> 文件，接着按下面这样增加 <code>ImportMetaEnv</code> 的定义：</p><div class="language-typescript"><pre><code><span class="token keyword">interface</span> <span class="token class-name">ImportMetaEnv</span> <span class="token punctuation">{</span>\n  <span class="token constant">VITE_APP_TITLE</span><span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token comment">// 更多环境变量...</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="modes"><a class="header-anchor" href="#modes" aria-hidden="true">#</a> 模式</h2><p>默认情况下，开发服务器 (<code>serve</code> 命令) 运行在 <code>development</code> (开发) 模式，而 <code>build</code> 命令运行在 <code>production</code> (生产) 模式。</p><p>这意味着当执行 <code>vite build</code> 时，它会自动加载 <code>.env.production</code> 中可能存在的环境变量：</p><div class="language-"><pre><code># .env.production\nVITE_APP_TITLE=My App\n</code></pre></div><p>在你的应用中，你可以使用 <code>import.<wbr>meta.env.VITE_APP_TITLE</code> 渲染标题。</p><p>然而，重要的是要理解 <strong>模式</strong> 是一个更广泛的概念，而不仅仅是开发和生产。一个典型的例子是，你可能希望有一个 “staging” (预发布|预上线) 模式，它应该具有类似于生产的行为，但环境变量与生产环境略有不同。</p><p>你可以通过传递 <code>--mode</code> 选项标志来覆盖命令使用的默认模式。例如，如果你想为我们假设的 staging 模式构建应用：</p><div class="language-bash"><pre><code>vite build --mode staging\n</code></pre></div><p>为了使应用实现预期行为，我们还需要一个 <code>.env.staging</code> 文件：</p><div class="language-"><pre><code># .env.staging\nNODE_ENV=production\nVITE_APP_TITLE=My App (staging)\n</code></pre></div><p>现在，你的 staging 应用应该具有类似于生产的行为，但显示的标题与生产环境不同。</p>',31);d.render=function(n,a,d,r,c,i){return e(),o("div",null,[t])};export default d;export{a as __pageData};
